#!/usr/bin/env python3
"""
Reads the config list and verifies that: 1. All listed config files exist, and 2. The combination of distros, arches,
and image-types produces at least one valid build configuration for each config file.

The config list is read as test/config-list.json relative to the repository root.
"""
import argparse
import copy
import json
import pathlib
import sys

import imgtestlib as testlib


def read_config_list(root):
    config_list_path = root / "test/config-list.json"
    if not config_list_path.exists():
        print(f"config list not found at {config_list_path}", file=sys.stderr)
        sys.exit(1)

    print(f"Reading config list: {config_list_path}")
    with config_list_path.open(encoding="utf-8") as config_list_fp:
        return json.load(config_list_fp), config_list_path.parent


def validate_config_file_paths(config_list, config_list_dir):
    """
    Validate that all paths in the config list exist. Paths must be relative to config_list_dir (the parent directory of
    the config list).

    Returns a list of paths found in the config list that were not found in the directory.
    """
    not_found = []
    for item in config_list:
        path = item["path"]
        config_path = config_list_dir / path
        if not config_path.exists():
            not_found.append(config_path)

    return not_found


def validate_build_config(config_list):
    """
    Validate that all build configurations (distros, arches, image types) match at least one valid, known configuration.

    Returns a list of 2-tuples, each consisting of the config file path and the build configuration.
    """
    no_matches = []
    for item in config_list:
        config = item["path"]
        filters = item["filters"]
        distros = filters.get("distros", ["*"])
        arches = filters.get("arches", ["*"])
        image_types = filters.get("image-types", ["*"])

        matches = testlib.list_images(distros=distros, arches=arches, images=image_types)
        if not matches:
            no_matches.append((config, filters))

    return no_matches


def filter_bootc(orig_config_list):
    """ returns a copy of the config_list without booc distros """
    config_list = copy.deepcopy(orig_config_list)
    for item in config_list:
        filters = item["filters"]
        if distros := filters.get("distros"):
            filters["distros"] = [
                d for d in distros if not d.startswith("bootc-")]

    return config_list


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("path", default=".", nargs="?", help="path to repository root")
    args = parser.parse_args()

    root = pathlib.Path(args.path)

    config_list, config_list_dir = read_config_list(root)

    print("Validating config file paths")
    not_found = validate_config_file_paths(config_list, config_list_dir)
    if not_found:
        print("  failed: the following config files were not found:", file=sys.stderr)
        for idx, path in enumerate(not_found, start=1):
            print(f"{idx}: {path}", file=sys.stderr)
        sys.exit(len(not_found))
    print("OK: All config files found")

    print("Validating build configurations (distros, arches, image types)")
    # filter out all bootc-* distros, they are "virtual" and will not
    # show up in "list-images" which is used to validate known distros
    no_matches = validate_build_config(filter_bootc(config_list))
    if no_matches:
        print("failed: the following configs do not match any known build configurations", file=sys.stderr)
        for idx, (config, build_config) in enumerate(no_matches, start=1):
            distros = ",".join(build_config.get("distros", ["*"]))
            arches = ",".join(build_config.get("arches", ["*"]))
            image_types = ",".join(build_config.get("image-types", ["*"]))
            print(f"{idx} {config}:", file=sys.stderr)
            print(f"  distros: {distros}", file=sys.stderr)
            print(f"  arches: {arches}", file=sys.stderr)
            print(f"  image types: {image_types}", file=sys.stderr)

        sys.exit(len(no_matches))
    print("OK: All test configs have at least one valid build configuration")


if __name__ == "__main__":
    main()
