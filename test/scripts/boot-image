#!/usr/bin/env python3
import argparse
import contextlib
import json
import os
import uuid
from tempfile import TemporaryDirectory

import imgtestlib as testlib


def get_aws_config():
    return {
        "key_id": os.environ.get("AWS_ACCESS_KEY_ID"),
        "secret_key": os.environ.get("AWS_SECRET_ACCESS_KEY"),
        "bucket": os.environ.get("AWS_BUCKET"),
        "region": os.environ.get("AWS_REGION")
    }


@contextlib.contextmanager
def create_ssh_key():
    with TemporaryDirectory() as tmpdir:
        keypath = os.path.join(tmpdir, "testkey")
        if ci_priv_key := os.environ.get("CI_PRIV_SSH_KEY_2"):
            # running in CI: use key from env
            with open(keypath, "w", encoding="utf-8") as keyfile:
                keyfile.write(ci_priv_key + "\n")
            os.chmod(keypath, 0o600)

            # get public key from priv key and write it out
            cmd = ["ssh-keygen", "-y", "-f", keypath]
            out, _ = testlib.runcmd(cmd)
            pubkey = out.decode()
            with open(keypath + ".pub", "w", encoding="utf-8") as pubkeyfile:
                pubkeyfile.write(pubkey)
        else:
            # create an ssh key pair with empty password
            cmd = ["ssh-keygen", "-t", "ecdsa", "-b", "256", "-m", "pem", "-N", "", "-f", keypath]
            testlib.runcmd_nc(cmd)

        yield keypath, keypath + ".pub"


@contextlib.contextmanager
def ensure_uncompressed(filepath):
    """
    If the file at the given path is compressed, decompress it and return the new file path.
    """
    base, ext = os.path.splitext(filepath)
    if ext == ".xz":
        print(f"Uncompressing {filepath}")
        # needs to run as root to set perms and ownership on uncompressed file
        testlib.runcmd_nc(["sudo", "unxz", "--verbose", "--keep", filepath])
        yield base
        # cleanup when done so the uncompressed file doesn't get uploaded to the build cache
        os.unlink(base)

    else:
        # we only do xz for now so it must be raw: return as is and hope for the best
        yield filepath


def cmd_boot_aws(arch, image_name, privkey, pubkey, image_path):
    aws_config = get_aws_config()
    cmd = ["go", "run", "./cmd/boot-aws", "run",
           "--access-key-id", aws_config["key_id"],
           "--secret-access-key", aws_config["secret_key"],
           "--region", aws_config["region"],
           "--bucket", aws_config["bucket"],
           "--arch", arch,
           "--ami-name", image_name,
           "--s3-key", f"images/boot/{image_name}",
           "--username", "osbuild",
           "--ssh-privkey", privkey,
           "--ssh-pubkey", pubkey,
           image_path, "test/scripts/base-host-check.sh"]
    testlib.runcmd_nc(cmd)


def boot_ami(distro, arch, image_type, image_path):
    with ensure_uncompressed(image_path) as raw_image_path:
        with create_ssh_key() as (privkey, pubkey):
            image_name = f"image-boot-test-{distro}-{arch}-{image_type}-" + str(uuid.uuid4())
            cmd_boot_aws(arch, image_name, privkey, pubkey, raw_image_path)


def boot_container(distro, arch, image_type, image_path, manifest_id):
    """
    Use bootc-image-builder to build an AMI and boot it.
    """
    # push container to registry so we can build it with BIB
    # remove when BIB can pull from containers-storage: https://github.com/osbuild/bootc-image-builder/pull/120
    container_name = f"iot-bootable-container:{distro}-{arch}-{manifest_id}"
    cmd = ["./tools/ci/push-container.sh", image_path, container_name]
    testlib.runcmd_nc(cmd)
    container_ref = f"{testlib.REGISTRY}/{container_name}"

    with TemporaryDirectory() as tmpdir:
        with create_ssh_key() as (privkey_file, pubkey_file):
            with open(pubkey_file, encoding="utf-8") as pubkey_fp:
                pubkey = pubkey_fp.read()

            # write a config to create a user
            config_file = os.path.join(tmpdir, "config.json")
            with open(config_file, "w", encoding="utf-8") as cfg_fp:
                config = {
                    "blueprint": {
                        "customizations": {
                            "user": [
                                {
                                    "name": "osbuild",
                                    "key": pubkey,
                                    "groups": [
                                        "wheel"
                                    ]
                                }
                            ]
                        }
                    }
                }
                json.dump(config, cfg_fp)

            # build an AMI
            cmd = ["sudo", "podman", "run",
                   "--rm", "-it",
                   "--privileged",
                   "--pull=newer",
                   "--security-opt", "label=type:unconfined_t",
                   "-v", f"{tmpdir}:/output",
                   "-v", f"{config_file}:/config.json",
                   "quay.io/centos-bootc/bootc-image-builder:latest",
                   "--type=ami",
                   "--config=/config.json",
                   container_ref]
            testlib.runcmd_nc(cmd)

            # boot it
            image_name = f"image-boot-test-{distro}-{arch}-{image_type}-" + str(uuid.uuid4())
            raw_image_path = f"{tmpdir}/image/disk.raw"
            cmd_boot_aws(arch, image_name, privkey_file, pubkey_file, raw_image_path)


def find_image_file(build_path: str) -> str:
    """
    Find the path to the image by reading the manifest to get the name of the last pipeline and searching for the file
    under the directory named after the pipeline. Raises RuntimeError if no or multiple files are found in the expected
    path.
    """
    manifest_file = os.path.join(build_path, "manifest.json")
    with open(manifest_file, encoding="utf-8") as manifest:
        data = json.load(manifest)

    last_pipeline = data["pipelines"][-1]["name"]
    files = os.listdir(os.path.join(build_path, last_pipeline))
    if len(files) > 1:
        error = "Multiple files found in build path while searching for image file"
        error += "\n".join(files)
        raise RuntimeError(error)

    if len(files) == 0:
        raise RuntimeError("No found in build path while searching for image file")

    return os.path.join(build_path, last_pipeline, files[0])


def main():
    desc = "Boot an image in the cloud environment it is built for and validate the configuration"
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("distro", type=str, default=None, help="distro for the image to boot test")
    parser.add_argument("arch", type=str, default=None, help="architecture of the image to boot test")
    parser.add_argument("image_type", type=str, default=None, help="type of the image to boot test")
    parser.add_argument("image_search_path", type=str, help="path to search for image file")

    args = parser.parse_args()
    distro = args.distro
    arch = args.arch
    image_type = args.image_type
    search_path = args.image_search_path

    image_path = find_image_file(search_path)

    print(f"Testing image at {image_path}")
    match image_type:
        case "ami" | "ec2" | "ec2-ha" | "ec2-sap" | "edge-ami":
            boot_ami(distro, arch, image_type, image_path)
        case "iot-bootable-container":
            info_file_path = os.path.join(search_path, "info.json")
            with open(info_file_path, encoding="utf-8") as info_fp:
                build_info = json.load(info_fp)
            manifest_id = build_info["manifest-checksum"]
            boot_container(distro, arch, image_type, image_path, manifest_id)
        case _:
            # skip
            print(f"{image_type} boot tests are not supported yet")
            return

    print("âœ… Marking boot successful")
    # amend build info with boot success
    # search_path is the root of the build path (build/build_name)
    info_file_path = os.path.join(search_path, "info.json")
    with open(info_file_path, encoding="utf-8") as info_fp:
        build_info = json.load(info_fp)
    build_info["boot-success"] = True
    with open(info_file_path, "w", encoding="utf-8") as info_fp:
        json.dump(build_info, info_fp, indent=2)


if __name__ == "__main__":
    main()
