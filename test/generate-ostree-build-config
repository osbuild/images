#!/usr/bin/env python3
import json
import os
import sys
from contextlib import contextmanager
from tempfile import NamedTemporaryFile, TemporaryDirectory

import imgtestlib as testlib

JOB_TEMPLATE = """
build/{distro}/{arch}/{image_type}/{config_name}:
  stage: test
  script:
    - sudo dnf install -y go gpgme-devel gcc
      osbuild osbuild-luks2 osbuild-lvm2 osbuild-ostree osbuild-selinux
      s3cmd podman
    - {start_container}
    - ./test/cases/build-image.sh "{distro}" "{image_type}" "{config}"
  extends: .terraform
  variables:
    RUNNER: aws/fedora-38-{arch}
    INTERNAL_NETWORK: "{internal}"
  needs:
    - pipeline: "$PARENT_PIPELINE_ID"
      job: generate-ostree-build-config-{arch}
"""


def read_config_map():
    with open(testlib.CONFIG_MAP, "r", encoding="utf-8") as config_map_file:
        return json.load(config_map_file)


def configs_with_deps(configs):
    """
    Return a config map with only the config files that have dependencies.
    """
    with_deps: dict[str, str] = {}
    config_map_dir = os.path.abspath(os.path.dirname(testlib.CONFIG_MAP))
    for path, filters in configs.items():
        # load config and check if it requires a commit
        config_path = os.path.join(config_map_dir, path)
        with open(config_path, "r", encoding="utf-8") as config_file:
            data = json.load(config_file)
        if not data.get("depends"):
            continue

        with_deps[config_path] = filters

    return with_deps


def gen_dependency_manifests(config_map, outputdir):
    """
    Generate manifests for the dependencies of the configs in config map. The function generates a temporary config map
    that maps each config that appears in a dependency to the dependency image type and runs gen-manifests with that
    config map.

    Returns a dictionary mapping manifest file name (without path) to the manifest data and its ID.
    """
    print("Generating manifests for dependencies")
    arches_arg = os.uname().machine
    dep_config_map: dict = {}  # config map for the dependencies
    gen_image_types = set()  # set of all the image types to generate manifests for

    # generate a config map for the dependencies
    for config_path in config_map.keys():
        with open(config_path) as config_file:
            cfg = json.load(config_file)

        dep = cfg["depends"]
        image_type = dep["image-type"]

        # dependency config path can be relative to config_path: make it absolute
        configs_dir = os.path.abspath(os.path.dirname(config_path))
        dep_config_path = os.path.join(configs_dir, dep["config"])

        dep_image_types = dep_config_map.get(dep_config_path, {}).get("image-types", [])
        dep_image_types.append(image_type)
        dep_config_map[dep_config_path] = {"image-types": dep_image_types}
        gen_image_types.add(image_type)

    # write dependency configs to temporary file and use as input to gen-manifests
    with NamedTemporaryFile(mode="w") as tmpfile:
        json.dump(dep_config_map, tmpfile)
        tmpfile.flush()
        cmd = ["go", "run", "./cmd/gen-manifests",
               "-cache", os.path.join(testlib.TEST_CACHE_ROOT, "rpmmd"),
               "-output", outputdir,
               "-workers", "100",
               "-images", ",".join(gen_image_types),
               "-config", tmpfile.name,
               "-arches", arches_arg]
        print(" ".join(cmd), flush=True)
        out, err = testlib.runcmd(cmd)

    # print stderr in case there were errors or warnings about skipped configurations
    # but filter out the annoying ones
    stderr = err.decode().splitlines()
    for line in stderr:
        if "No match for group package" in line:
            continue
        if "Failed to load consumer certs" in line:
            continue
        print(line)

    print("Manifest generation done!\n")
    return testlib.read_manifests(outputdir)


def gen_image_manifests(config_map, configs, outputdir):
    """
    Write the config map and configs to a temporary directory and generate the corresponding manifests in the output
    directory. The manifest generation skips any distro + arch + image-type configuration that isn't covered by the
    config map.

    Returns a dictionary mapping manifest file name (without path) to the manifest data and its ID.
    """
    arches_arg = os.uname().machine
    with TemporaryDirectory() as tmpdir:
        # write each config to a separate file
        for config in configs.values():
            with open(os.path.join(tmpdir, config["name"] + ".json"), "w", encoding="utf-8") as config_file:
                json.dump(config, config_file)

        # write config map in the same dir
        config_map_path = os.path.join(tmpdir, "config-map.json")
        with open(config_map_path, "w", encoding="utf-8") as config_map_file:
            json.dump(config_map, config_map_file)

        cmd = ["go", "run", "./cmd/gen-manifests",
               "-cache", os.path.join(testlib.TEST_CACHE_ROOT, "rpmmd"),
               "-output", outputdir,
               "-workers", "100",
               "-config", config_map_path,
               "-commits=true",  # resolve ostree commit sources
               "-skip-noconfig",  # skip configs that aren't in the config-map
               "-arches", arches_arg]
        print(" ".join(cmd))
        out, err = testlib.runcmd(cmd)

    # print stderr in case there were errors or warnings about skipped configurations
    # but filter out the annoying ones
    stderr = err.decode().splitlines()
    for line in stderr:
        if "No match for group package" in line:
            continue
        if "Failed to load consumer certs" in line:
            continue
        print(line)

    print("Manifest generation done!\n")
    return testlib.read_manifests(outputdir)


def default_ref(distro, arch):
    name, version = distro.split("-")
    if name == "rhel":
        version = version[0]  # this will break on RHEL 10
        product = "edge"
    elif name == "fedora":
        product = "iot"
    elif name == "centos":
        product = "edge"

    return f"{name}/{version}/{arch}/{product}"


@contextmanager
def setup_dependencies(manifests, config_map):
    """
    For each config in the config map, list all image configurations (distro, arch, image type) that it applies to and
    use the manifests to find the corresponding manifest IDs. Pull and run the corresponding dependency container from
    the registry and write a new config (and config map) that replaces the ostree options with the container URL and
    port.
    The config map and configs that function yields can be used to generate manifests with ostree commits resolved.
    The containers are stopped when the context exits.
    """
    container_ids = []
    new_config_map: dict[str, dict] = {}
    new_configs = {}

    container_ports: dict[str, int] = {}
    for config_path, filters in config_map.items():
        with open(config_path) as config_file:
            config_data = json.load(config_file)
        config_name = config_data["name"]

        # dependency config path is relative to config file
        dep_config_path = os.path.join(os.path.dirname(config_path), config_data["depends"]["config"])
        with open(dep_config_path) as dep_config_file:
            dep_config_data = json.load(dep_config_file)
        dep_config_name = dep_config_data["name"]
        dep_image_type = config_data["depends"]["image-type"]

        # get all image configurations that this config applies to
        arches = [os.uname().machine]
        image_configs = testlib.list_images(distros=filters.get("distros"),
                                            arches=arches,
                                            images=filters.get("image-types"))

        for image_config in image_configs:
            distro = image_config["distro"]
            arch = image_config["arch"]
            image_type = image_config["image-type"]
            dep_build_name = testlib.gen_build_name(distro, arch, dep_image_type, dep_config_name)
            manifest_id = manifests[dep_build_name + ".json"]["id"]
            container = f"{testlib.REGISTRY}/{dep_build_name}:build-{manifest_id}"

            # start each container once on an incremental port
            port = container_ports.get(container)
            if not port:
                # Pulling and launching the container will fail if the specific container config was never built.  This
                # can happen if a dependency is specified that does not exist in the config-map.
                port = 42000 + len(container_ports)
                container_ports[container] = port

            # modify image config with container address and ref
            config_name = config_data["name"]
            config_name = f"{config_name}-{port}"
            new_config = {
                "name": config_name,
                "ostree": {
                    "url": f"http://localhost:{port}/repo",
                    # get the ref from the current config, or compute the default if unset
                    "ref": config_data.get("ostree", {}).get("ref", default_ref(distro, arch)),
                },
                "blueprint": config_data.get("blueprint"),

                # this is not part of the standard config, but it's convenient to add it and it wont interfere
                "container": {
                    "name": container,
                    "port": port,
                }
            }
            new_configs[config_name] = new_config

            config_fname = config_name + ".json"
            new_filters = new_config_map.get(config_fname, {"distros": [], "arches": [], "image-types": []})
            new_filters["distros"].append(distro)
            new_filters["arches"].append(arch)
            new_filters["image-types"].append(image_type)
            new_config_map[config_fname] = new_filters

    try:
        for config in new_configs.values():
            container = config["container"]["name"]
            port = config["container"]["port"]
            print(f"Starting container {container} {port}")
            cont_id, _ = testlib.runcmd(["podman", "run", "-d", "--rm", f"-p{port}:8080", container])
            container_ids.append(cont_id.strip().decode())

        yield new_config_map, new_configs
    finally:
        print("Stopping containers")
        print("\n".join(container_ids))
        for cont_id in container_ids:
            testlib.runcmd(["podman", "stop", cont_id])


def generate_configs(build_requests, pull_configs, pipeline_file, configs_dir):
    print(f"Generating dynamic pipelines for {len(build_requests)} builds")
    os.makedirs(configs_dir, exist_ok=True)
    for build in build_requests:
        distro = build["distro"]
        arch = build["arch"]
        image_type = build["image-type"]
        config = build["config"]

        config_name = config["name"]

        # write the config to the artifacts directory
        build_config_path = os.path.join(configs_dir, config_name + ".json")
        with open(build_config_path, "w", encoding="utf-8") as build_config_file:
            json.dump(config, build_config_file)

        # generate script line to pull and start container
        container = pull_configs[config_name]["container"]
        container_name = container["name"]
        container_port = container["port"]
        container_cmd = f"podman run -d --rm -p{container_port}:8080 {container_name}"

        pipeline_file.write(JOB_TEMPLATE.format(distro=distro, arch=arch, image_type=image_type,
                                                config_name=config_name, config=build_config_path,
                                                start_container=container_cmd,
                                                internal="true" if "rhel" in distro else "false"))
    print("DONE!")


def main():
    config_path = sys.argv[1]
    configs_dir = sys.argv[2]

    testlib.check_config_names()

    config_map = configs_with_deps(read_config_map())  # filtered config map: only configs with deps

    with TemporaryDirectory() as cache_root:
        dep_manifest_dir = os.path.join(cache_root, "dependencies")
        dep_manifests = gen_dependency_manifests(config_map, dep_manifest_dir)

        with setup_dependencies(dep_manifests, config_map) as (pull_config_map, pull_configs):
            manifest_dir = os.path.join(cache_root, "manifests")
            manifests = gen_image_manifests(pull_config_map, pull_configs, manifest_dir)

        build_requests = testlib.filter_builds(manifests, skip_ostree_pull=False)

    with open(config_path, "w") as config_file:
        if len(build_requests) == 0:
            print("No manifest changes detected. Generating null config.")
            config_file.write(testlib.NULL_CONFIG)
            return

        config_file.write(testlib.BASE_CONFIG)
        generate_configs(build_requests, pull_configs, config_file, configs_dir)


if __name__ == "__main__":
    main()
